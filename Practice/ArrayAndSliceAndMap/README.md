### 数组，切片和字典

Go 内置的高级数据类型：数组，切片和字典。

> 数组(Array)

[Array.go](Array.go)

数组是一个具有`相同数据类型`的元素组成的`固定长度`的`有序集合`。

```go
var x [5]int
```

以上表示数组 x 是一个整型数组，而且数值的长度为 5。

数组的定义方法有以下几种：

```go
// 1.
var x [5]int
x[0] = 1
x[1] = 2
...
x[4] = 5

// 2. 知道数组的初始值
var x = [5]int{1, 2, 3, 4}
x[4] = 5

// 3. 不知道数组元素的初始值
var x = [5]int{}
x[0] = 1
x[1] = 2
...
x[4] = 5

// 4. 数组是在固定长度的，但是我们有时候也可以不显式指定数组的长度，而是使用`...`来替代数组长度，
// Go 语言会自动计算出数组的长度。不过这种方式定义的数组一定是有初始化的值的。
// 这种方式在调试程序的时候特别方便，可以注释某些元素而不需要同时修改数组的长度
var x = [...]string{
	"Monday",
	"Tuesday",
	"Wednesday",
	"Thursday",
	"Friday",
	"Saturday",
	"Sunday"}
```

`Array.go`中使用了一种遍历数组元素的方法。该方法利用 Go 语言提供的内置函数 range 来遍历数组元素。
`range 函数可以用在数组，切片和字典上面。`当 range 遍历数组时返回数组的索引和元素值。当对一个函数
返回值不感兴超的话，可以用下划线`_`来替代它。

> 切片

[Slice.go](Slice.go)

上面知道数组是固定长度的有序集合。也就是说一旦数组定义了，将无法在数组里添加或删除元素。当元素个数不
确定的时候，这是一个很大的缺点。由此`切片`诞生了。

切片和数组很类亿，其至可以理解为数组的子集。但是，切片跟数组最大的区别就是切片的长度是可变的。

切片有`容量(capacity)`和`长度(length)`两个属性。

切片有两种定义方式：

1. 先声明一个变量是切片，再使用内置 make 函数去初始化它：`var x = make([]int, 5, 5)`；

2. 通过数组切片来赋值：`var x = arr[low_index:high_index]`，x 切片元素包括 low_index 的元素，不包括
   high_index 的元素，其中 low_index 和 high_index 可以省略其中一个；省略 low_index 默认从索引 0 开始，
   省略 high_index 默认 high_index 为 len(arr)，即切片长度；
   
其实还可以这样子啊：`x := []int{1, 2, 3, 4, 5}`。

`Slice.go`中使用了 make 函数定义切片，第 2 个参数指定切片长度，第 3 个参数指定切片容量；如果第 3 个参数不
填，默认长度与容量相同；切片的最大索引是 len(x) - 1。

切片长度是可变的，可以使用 append 方法为其追加元素。如果追加元素后超过了容量，`Go 会自动重新为切片为分配容量，
容量大小为原来的两倍`。

copy 函数用来从一个切片拷贝元素到另一个切片。


> 字典(Map)

[Map.go](Map.go)

字典是一组`无序的`，`键值对`的`集合`。

字典也叫做`关联数组`，因为数组通过索引来查找元素，而字典通过`键`来查找元素。

字典的定义也有两种：一种是初始化数据的定义方式，男一种是使用 make 函数来定义的。

`Map.go`中，定义了一个 string:string 的字典，其中`[]`之间的键类型，右边的是值类型。range 函数返回 key:value 键值对。
当然也可以用`_`来忽略返回值。

**字典的访问方式**：

```go
x := make(map[string]int)

x["A"] = 0
x["B"] = 1

fmt.Println(x["C"])  // 0
if val, ok := x["C"]; ok {
	fmt.Println(val)
}
```

从上例中看出，`x["C"]`的返回值有两个，一个是值，别一个是是否存在此键的布尔型变量，所以我们看到 ok 为 true 时就
输出键 C 的值，如果 ok 为 false, 那字典中就不存在该键。

Go 内置的函数 delete 可以用来从字典中删除元素。
