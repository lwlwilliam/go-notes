# 包的初始化

包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：

```
var a = b + c // a 第三个初始化，为 3
var b = f() // b 第二个初始化，为 2，通过调用 f（依赖 c）
var c = 1 // c 第一个初始化，为 1

func f() int { return c + 1 }
```

**在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明。**

注意：

```
var cwd string

func init() {
    cwd, err := os.Getwd()  // compile error: unused: cwd
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err) 
    }
}
```

以上代码中，虽然 cwd 在外部已经声明过，但是`:=`语句还是将 cwd 和 err 重新声明为新的局部变量。因为内
部声明的 cwd 将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的 cwd 变量。

如果包中含有多个 .go 源文件，它们将按照发给编译器的顺序进行初始化，Go 语言的构建工具首先会将 .go 文件
根据文件名排序，然后依次调用编译器编译。

对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初
始化并不是一个简单的赋值过程。在这种情况下，可以用一个特殊的 init 初始化函数来简化初始化工作。每个文件都
可以包含多个 init 初始化函数。

```
func init() { /*...*/ }
```

这样的 init 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的 init 初始化函数，
在程序开始执行时按照它们声明的顺序被自动调用。

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 p 包导入了 q 包，
那么在 p 包初始化的时候可以认为 q 包必然已经初始化过了。初始化工作是自下而上进行的，main 包最后被初始化。
以这种方式，可以确保在 main 函数执行之前，所有依赖的包都已经完成初始化工作了。