# 方法

从 90 年代早期开始，面向对象编程(OOP)就成了称霸工程界和教育界的编程范式，所以之后几乎所有大规模被应用的语言都包含了对 OOP 的支持，
go 语言也不例外。

尽管没有被大众所接受的明确的 OOP 的定义，从我们的理解来讲，一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，
而一个方法则是一个和特殊类型关联的函数。一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作
对象，而是借助方法来做这些事情。

### 方法声明

在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。
[geometry.go](./geometry/geometry.go) 中附加的参数 p，叫做方法的接收器(receiver)，早期的面向对象语言留下的遗产将调用一个方法称为
"向一个对象发送消息"。

在 Go 语言中，不会像其它语言那样使用 this 或者 self 作为接收器；我们可以任意地选择接收器的名字。由于接收器的名字经常会被使用，所以
保持其在方法间传递时的一致性和简短性是不错的主意。在方法调用时，接收器参数一般会在方法名之前出现[geometry.go](./cmd/geometry.go)。
如`p.Distance(p)`的表达式叫做选择器。选择器也会被用来选择一个 struct 类型的字段，如 p.X。由于方法和字段都是在同一命名空间，所以如果
在这里声明一个 X 方法的话，编译器会报错，因为在调用 p.X 时会有歧义。每种类型都有其方法的命名空间，因此多个类型可以定义同名的方法，如
[path.go](./geometry/path.go)中的 Path 类型。在能够给任意类型定义方法这一点上，Go 和很多其它的面向对象的语言不太一样。因此在
Go 语言里，我们为一些简单的数值、字符串、slice、map 来定义一些附加行为很方便。我们可以给同一包内的任意命名类型定义方法，只要这个命名
类型的底层类型不是指针或 interface。在对方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。

### 基于指针对象的方法

方法调用与函数调用类似，调用时会对参数值进行拷贝，当需要更新变量时，或者参数太大时，需要用到指针。如下：

```go
func (p *Point) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}
```

这个方法的名字是`(*Point).ScaleBy`。这里的括号是必须的；没有括号的话这个表达式可能会被理解为`*(Point.ScaleBy)`。

在现实的程序中，一般会约定如果 Point 这个类有一个指针作为接收器的方法，那么所有 Point 的方法都必须有一个指针接收器，即使是那些
并不需要这个指针接收器的函数。`这里为了展示，，打破这个约定。`此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，
是不允许其出现在接收器中的，比如下例：

```go
type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
```

以下三种方法的调用方式都是可以的：

1.  接收器的实参和形参相同，比如两者都是类型 T 或都是类型`*T`；
2.  接收器的实参是类型 T，形参是类型`*T`，这种情况下编译器会隐式地为我们取变量地址；
3.  接收器的实参是类型`*T`，形参是类型 T。编译器会隐式地为我们解引用，取到指针指向的实际变量；

#### Nil 也是一个合法的接收器类型

就像一些函数允许 nil 指针作为参数一样，方法理论上也可以用 nil 作为其接收器，尤其当 nil 对于对象来说是合法的零值时，比如 map 或 slice。
如例[intList.go](./intList/intList.go)。

### 通过嵌入结构体来扩展类型

如[colorPoint.go](./cmd/colorPoint.go)，可以直接认为通过嵌入的字段就是 ColoredPoint 自身的字段，而完全不需要在调用时指出 Point。
同理，Point 中的方法也可以类似使用。用嵌入的方式，可以使我们定义字段特别多的复杂类型，可以将字段先按小类型分组，然后定义小类型的方法，之
后再把它们组合起来。可以类比基于类来实现面向对象的语言，把 Point 看作是一个基类，而 ColoredPoint 看作其子类或者继承类，或者将 ColoredPoint
看作 "is a" Point 类型。 **但这是错误的理解。** 注意上例中对 Distance 方法的调用。Distance 有一个参数是 Point 类型，但 q 并不是一个
Point 类，所以尽管 q 有着 Point 这个内嵌类型，我们也必须要显式地选择它。尝试直接传 q 的话会看到下面的错误：

```go
p.Distance(q)  // compile error: cannot use q (ColoredPoint) as Point
```

一个 ColoredPoint 并不是一个 Point，但它 "has a" Point，并且它有从 Point 类里引入的 Distance 和 Test 方法。如果喜欢从实现的角度来
考虑问题，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的：

```go
func (p ColoredPoint) Distance(q Point) float64 {
	return p.Point.Distance(q)
}
```

当 Point.Distance 被第一个包装方法调用时，它的接收器值是 p.Point，而不是 p，当然了，在 Point 类的方法里，你是访问不到 ColoredPoint
的任何字段的。

在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中（访问需要通过该指针指向的对象去取）。添加
这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。