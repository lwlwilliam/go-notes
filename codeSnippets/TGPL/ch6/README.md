# 方法

从 90 年代早期开始，面向对象编程(OOP)就成了称霸工程界和教育界的编程范式，所以之后几乎所有大规模被应用的语言都包含了对 OOP 的支持，
go 语言也不例外。

尽管没有被大众所接受的明确的 OOP 的定义，从我们的理解来讲，一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，
而一个方法则是一个和特殊类型关联的函数。一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作
对象，而是借助方法来做这些事情。

### 方法声明

在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。
[geometry.go](./geometry/geometry.go) 中附加的参数 p，叫做方法的接收器(receiver)，早期的面向对象语言留下的遗产将调用一个方法称为
"向一个对象发送消息"。

在 Go 语言中，不会像其它语言那样使用 this 或者 self 作为接收器；我们可以任意地选择接收器的名字。由于接收器的名字经常会被使用，所以
保持其在方法间传递时的一致性和简短性是不错的主意。在方法调用时，接收器参数一般会在方法名之前出现[geometry.go](./cmd/geometry.go)。
如`p.Distance(p)`的表达式叫做选择器。选择器也会被用来选择一个 struct 类型的字段，如 p.X。由于方法和字段都是在同一命名空间，所以如果
在这里声明一个 X 方法的话，编译器会报错，因为在调用 p.X 时会有歧义。每种类型都有其方法的命名空间，因此多个类型可以定义同名的方法，如
[path.go](./geometry/path.go)中的 Path 类型。在能够给任意类型定义方法这一点上，Go 和很多其它的面向对象的语言不太一样。因此在
Go 语言里，我们为一些简单的数值、字符串、slice、map 来定义一些附加行为很方便。我们可以给同一包内的任意命名类型定义方法，只要这个命名
类型的底层类型不是指针或 interface。在对方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。

### 基于指针对象的方法

方法调用与函数调用类似，调用时会对参数值进行拷贝，当需要更新变量时，或者参数太大时，需要用到指针。如下：

```go
func (p *Point) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}
```

这个方法的名字是`(*Point).ScaleBy`。这里的括号是必须的；没有括号的话这个表达式可能会被理解为`*(Point.ScaleBy)`。

在现实的程序中，一般会约定如果 Point 这个类有一个指针作为接收器的方法，那么所有 Point 的方法都必须有一个指针接收器，即使是那些
并不需要这个指针接收器的函数。`这里为了展示，，打破这个约定。`此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，
是不允许其出现在接收器中的，比如下例：

```go
type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
```

以下三种方法的调用方式都是可以的：

1.  接收器的实参和形参相同，比如两者都是类型 T 或都是类型`*T`；
2.  接收器的实参是类型 T，形参是类型`*T`，这种情况下编译器会隐式地为我们取变量地址；
3.  接收器的实参是类型`*T`，形参是类型 T。编译器会隐式地为我们解引用，取到指针指向的实际变量；

#### Nil 也是一个合法的接收器类型

就像一些函数允许 nil 指针作为参数一样，方法理论上也可以用 nil 作为其接收器，尤其当 nil 对于对象来说是合法的零值时，比如 map 或 slice。
如例[intList.go](./intList/intList.go)。

### 通过嵌入结构体来扩展类型

如[colorPoint.go](./cmd/colorPoint.go)，可以直接认为通过嵌入的字段就是 ColoredPoint 自身的字段，而完全不需要在调用时指出 Point。
同理，Point 中的方法也可以类似使用。用嵌入的方式，可以使我们定义字段特别多的复杂类型，可以将字段先按小类型分组，然后定义小类型的方法，之
后再把它们组合起来。可以类比基于类来实现面向对象的语言，把 Point 看作是一个基类，而 ColoredPoint 看作其子类或者继承类，或者将 ColoredPoint
看作 "is a" Point 类型。 **但这是错误的理解。** 注意上例中对 Distance 方法的调用。Distance 有一个参数是 Point 类型，但 q 并不是一个
Point 类，所以尽管 q 有着 Point 这个内嵌类型，我们也必须要显式地选择它。尝试直接传 q 的话会看到下面的错误：

```go
p.Distance(q)  // compile error: cannot use q (ColoredPoint) as Point
```

一个 ColoredPoint 并不是一个 Point，但它 "has a" Point，并且它有从 Point 类里引入的 Distance 和 Test 方法。如果喜欢从实现的角度来
考虑问题，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的：

```go
func (p ColoredPoint) Distance(q Point) float64 {
	return p.Point.Distance(q)
}
```

当 Point.Distance 被第一个包装方法调用时，它的接收器值是 p.Point，而不是 p，当然了，在 Point 类的方法里，你是访问不到 ColoredPoint
的任何字段的。

在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中（访问需要通过该指针指向的对象去取）。添加
这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系，如[share.go](./cmd/share.go)中的
`q.Point = p.Point`。

方法只能在命名类型或者指向类型的指针上定义，但是多亏了内嵌，有时候给匿名 struct 类型来定义方法也有
了手段。

```go
var (
	mu sync.Mutex   // guards mapping
	mapping = make(map[string]string)
)

func Lookup(key string) string {
	mu.Lock()
	v := mapping[key]
	mu.Unlock()
	return v
}
```

下面的版本与以上功能是一致的，但将两个包级变量放在了 cache 这个 struct 一组内：

```go
var cache = struct {
	sync.Mutex
	mappint map[string]string
}{
	mapping: make(map[string]string),
}

func Lookup(key string) string {
	cache.Lock()
	v := cache.mapping[key]
	cache.Unlock()
	return v
}
```

给新的变量起了一个更具表达性的名字：cache。因为 sync.Mutex 字段也被嵌入到这个 struct 里，其
Lock 和 Unlock 方法也就都被引入到这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行
加锁解锁操作。

### Bit 数组: TODO

Go 语言里的集合一般会用 map[T]bool 这种形式来表示，T 代表元素类型。集合用 map 类型来表示虽然
非常灵活，但可以以一种更好的形式来表示它，bit 数组会比 map 数组表现更加理想。比如我们执行一个
http 下载任务，把文件按照 16kb 一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种
时候也需要用到 bit 数组。

一个 bit 数组通常会用一个无符号数或者称之为“字”的 slice 来表示，每一个元素的每一位都表示集合里的
一个值。当集合的第 i 位被设置时，我们才说这个集合包含元素 i。

### 封装

一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，
同时也是面向对象编程最关键的一个方面。

Go 语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种
限制包内成员的方式同样适用于 struct 或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其
定义为一个 struct。

这种基于名字的手段使得在语言中最小的封装单元是 package，而不是像其它语言一样的类型。一个 struct
类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。

封装提供了三方面的优点。首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄
懂少量变量的可能的值即可。

第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的
api 情况下能得到更大的自由。

封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。因为对象内部变量
只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。

只用来访问或修改内部变量的函数被称为 setter 或者 getter。
