### 切片和数组概述

> 原文：[https://yourbasic.org/golang/slices-explained/](https://yourbasic.org/golang/slices-explained/)

#### 基础

切片不保存任何数据，它只描述底层数组的一部分。

*   当改变切片的一个元素时，同时也修改了底层数组中对应的元素，共享同一个底层数组的其它切片也会被改变；
*   一个切片可以在底层数组的边界范围内进行缩放；

#### 创建（切片）

```
var s []int                     // a nil slice
s1 := []string{"foo", "bar"}
s2 := make([]int, 2)            // same as []int{0, 0}
s3 := make([]int, 2, 4)         // same as new([4]int)[:2]
fmt.Println(len(s3), cap(s3)    // 2 4
```

*   切片的默认零值为 nil。len、cap 和 append 函数都将 nil 视为容量为 0 的空切片。
*   可以通过字面量或者 make 函数创建切片，make 函数接收一个长度和一个可选的容量参数。
*   内置的 len 和 cap 函数分别用来查询（切片）的长度和容量。

#### 切片

```
a := [...]int{0, 1, 2, 3}   // an array
s := a[1:3]                 // s == []int{1, 2}         cap(s) == 3
s = a[:2]                   // s == []int{0, 1}         cap(s) == 4 
s = a[2:]                   // s == []int{2, 3}         cap(s) == 2
s = a[:]                    // s == []int{0, 1, 2, 3}   cap(s) == 4
```

可以通过已有的数组或切片创建新切片。

*   切片由指定的低边界和高边界组成：a[low:high]。这是一个包含首个元素但不包含最后一个元素的半开放范围。
*   也省略高边界或低边界，这样就会使用对应的默认边界值。低边界的默认值是 0，高边界的默认值是切片的长度。

```
s := []int{0, 1, 2, 3, 4}   // a slice
s = s[1:4]                  // s == []int{1, 2, 3}
s = s[1:2]                  // s == []int{2} (index 与 s 切片关联)
s = s[:3]                   // s == []int{2, 3, 4} (延长长度)
```

当对一个切片再切片时，索引是与切片自身相关的，而不是与底层数组相关。

*   高边界不是由切片的长度决定的，而是由容量决定，这意味着可以延长切片的长度。
*   试图延长的切片超出容量将会导致 panic。 

#### 迭代

```
s := []string{"Foo", "Bar"}
for i, v := range s {
    fmt.Println(i, v)
}
```

*   range 表达式中，s 会在循环开始前计算一次。
*   迭代值分别被赋值到对应的变量 i 和 v 中，就像赋值表达式一样。
*   第二个迭代变量是可选的。
*   如果切片为 nil，迭代次数为 0。

#### 追加和复制

*   append 函数向切片追回元素。如果容量超出原来的，append 会自动分配一个更大的底层数组给切片。
*   copy 函数从 src(源) 切片向 dst（目标）切片复制元素。复制的数量是 len(dst) 和 len(src) 的最小值。

#### 栈和队列

在 Go 中实现一个栈或队列的惯用方法是直接使用切片。以下例子只包括基本原理，并没有完整实现。

后进先出，LIFO: [stack.go](../src/stack.go)
先进先出，FIFO: [queue.go](../src/queue.go)
