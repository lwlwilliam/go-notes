# 标准库

Go 标准库是一组核心包，用来扩展和增加语言的能力。这些包为语言增加了大量不同的类型。开发人员可以直接使用这些类型，而不用再写自己的包或者去下载
其他人发布的第三方包。由于这些包和语言绑在一起发布，它们会得到以下特殊的保证：

*   每次语言更新，哪怕是小更新，都会带有标准库；

*   这些标准库会严格向后兼容的承诺；

*   标准库是 Go 语言开发、构建、发布过程的一部分；

*   标准库由 Go 的构建者们维护和评审；

*   每次 Go 语言发布新版本时，标准库都会被测试，并评估性能；

这些保证让标准库变得很特殊，应尽量利用这些标准库。使用标准库里的包可以使管理代码变得更容易，并且保证代码的稳定。不用担心程序无法兼容不同的 Go
语言版本，也不用管理第三方依赖。

## 文档与源代码

标准库里总共有超过 100 个包，这些包被分到 38 个类别里，如下：`archive`、`bufio`、`bytes`、`compress`、`container`、`cryto`、
`database`、`debug`、`encoding`、`errors`、`expvar`、`flag`、`fmt`、`go`、`hash`、`html`、`image`、`index`、`io`、`log`、
`math`、`mime`、`net`、`os`、`path`、`reflect`、`regexp`、`runtime`、`sort`、`strconv`、`strings`、`sync`、`syscall`、`testing`、
`text`、`time`、`unicode`、`unsafe`。

以上许多分类本身就是一个包。

不管用什么方式安装 Go，标准库的源代码都会安装在`$GOROOT/src/pkg`（注：这里应该错了吧，是`$GOROOT/src`才对）文件夹里。拥有标准库的源代码对
Go 工具正常工作非常重要。类似 godoc、gocode 甚至 go build 这些工具，都需要读取标准库的源代码才能完成其工作。如果源代码没有安装在以上文件夹
中，或者无法通过 $GOROOT 变量访问，在试图编译程序时会产生错误。

作为 Go 发布包的一部分，标准库的源代码是经过预编译的。这些预编译后的文件，称作**归档文件(archive file)**，可以在`$GOROOT/pkg`文件中找到
已经安装的各目标平台和操作系统的归档文件，也就是扩展名为`.a`的文件。这些文件是特殊的 Go 静态库文件，由 Go 的构建工具创建，并在编译和链接最终
程序时被使用。归档文件可以让构建的速度更快。但是在构建的过程中，没办法指定这些文件，所以没办法与别人共享这些文件。Go 工具链知道什么时候可以使用
已有的`.a`文件，什么时候需要从机器上的源代码重新构建。

下面来看一下标准库里的几个包，看看如何用这些包来构建自己的程序。

## 记录日志

即使没有表现出来，程序依旧可能有 bug。这在软件开发里是很自然的事情。日志是一种找到这些 bug，更好地了解程序工作状态的方法。日志是开发人员的眼睛
和耳朵，可以用来跟踪、调试和分析代码。基于此，标准库提供了 log 包，可以对日志做一些最基本的配置。根据特殊需要，还可以自己定制日志记录器。

在 UNIX 里，日志有很长的历史。传统的 CLI 程序直接将输出写到名为 stdout 的设备上。所有的操作系统上都有这种设备，这种设备的默认目的地是标准文
本输出。默认设置下，终端会显示这些写到 stdout 设备上的文本。然而这种单个目的地的输出，总会碰到需要同时输出程序信息和输出执行细节的情况。这些执
行细节被称作日志。当想要记录日志时，希望能写到不同的目的地，这样就不会将程序的输出和日志混在一起了。

为了解决这个问题，UNIX 架构上增加了一个叫作 stderr 的设备。这个设备被创建为日志的默认目的地。这个就能将程序的输出和日志分离开来。如果想在程序
运行时同时看到程序输出和日志，可以将终端配置为同时显示写到 stdout 和 stderr 的信息。不过，如果用户的程序只记录日志，没有程序输出，更常用的方
式是将一般的日志信息写到 stdout，将错误或者警告信息写到 stderr。

### log 包

记录日志的目的是跟踪程序什么时候在什么位置做了什么。这就需要通过某些配置在每个日志项上要写的一些信息，如以下代码清单：

```
TRACE: 2018/01/01 11:11:11.000000 /tmpfs/gosandbox-/prog.go:14: message
```

可以看到一个由 log 包产生的日志项。这个日志项包含前缀、日期时间戳、该日志具体是由哪个源文件记录的、源文件记录日志所在行，最后
是日志消息。看一下如何配置 log 包来输出这样的日志项，[listing03.go](listing03.go)

### 定制的日志记录器

要想创建一个定制的日志记录器，需要创建一个 Logger 类型值。可以给每个日志记录器配置一个单独的目的地，并独立设置其前缀和标志，
[listing11.go](listing11.go)

## 编码/解码(TODO)

许多程序都需要处理或者发布数据，不管这个程序是要使用数据库，进行网络调用，还是与分布式系统打交道。如果程序需要处理 XML 或者 JSON，可以使用标
准库里名为 xml 和 json 的包，它们可以处理这些格式的数据。如果想实现自己的数据格式的编解码，可以将这些包的实现作为指导。

在今天，JSON 远比 XML 流行。这主要是因为与 XML 相比，使用 JSON 需要处理的标签更少。这就意味着网络传输时每个消息的数据更少，从而提升整个系统
的性能。而且，JSON 可以转换为 BSON（Binary JavaScript Object Notation，二进制 JavaScript 对象标记），进一步缩小每个消息的数据长度。

### 解码 JSON

看一个处理 Get 请求响应的 JSON 的例子，这个例子使用 http 包获取 Google 搜索 API 返回的 JSON。代码清单展示了这个响应的内
容[api.json](api.json)。

### 编码 JSON

## 输入和输出

类 Unix 的操作系统如此伟大的一个原因是，一个程序的输出可以是另一个程序的输入这一理念。依照这个哲学，这类操作系统创建了一系列
的简单程序，每个程序只做一件事，并把这件事做得非常好。之后，将这些程序组合在一起，可以创建一些脚本做一些很惊艳的事情。这些
程序使用 stdin 和 stdout 设备作为通道，在进程之间传递数据。

同样的理念扩展到了标准库的 io 包，而且提供的功能很神奇。这个包可以以流的方式高效处理数据，而不用考虑数据是什么，数据来自哪里，
以及数据要发送到哪里的问题。与 stdout 和 stdin 对应，这个包含有 io.Writer 和 io.Reader 两个接口。所有实现了这两个接口的类型的
值，都可以使用 io 包提供的所有功能，也可以用于其他包里接受这两个接口的函数以及方法。这是用接口类型来构造函数和 API 最美妙的
地方。可以基于这些再有功能进行组合，利用所有已经存在的实现，专注于解决业务问题。

### Writer 和 Reader 接口

io 包是围绕着实现了 io.Writer 和 io.Reader 接口类型的值而构建的。由于 io.Writer 和 io.Reader 提供了足够的抽象，这些 io 包里的
函数和方法并不知道数据的类型，也不知道这个数据在物理上是如何读和写的。以下是 io.Writer 接口的声明。

```
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

这个接口声明了唯一一个方法 Write，这个方法接受一个 byte 切片，并返回两个值。第一个是写入的字节数，第二个是 error 错误值。以
下是实现这个方法的一些规则。

```
Write 从 p 里向底层的数据流写入 len(p) 字节的数据。这个方法返回从 p 里写出的字节数(0 <= n <= len(p))，以及任何可能导致写入
提前结束的错误。Write 在返回 n < len(p) 的时候，必须返回某个非 nil 值的 error。Write 绝不能改写切片里的数据，哪怕是临时修改
也不行。
```

以上规则来自标准库。这些规则意味着 Write 方法的实现需要试图写入被传入的 byte 切片里的所有数据。但是，如果无法全部写入，那么该
方法就一定会返回一个错误。返回的写入字节数可能小于 byte 切片的长度，但不会出现大于的情况。最后，不管什么情况，都不能修改 byte
切片里的数据。

再看看 Reader 接口的声明。

```
type Reader interface {
	Read(p []byte) (n int, err error)
}
```

该接口声明了一个方法 Read，这个方法接受一个 byte 切片，并返回两个值。第一个值是读入的字节数，第二个是 error 错误值。以下是实现
这个方法的一些规则。

```
1.	Read 最多读入 len(p) 字节，保存到 p。这个方法返回读入的字节数(0 <= n <= len(0))和任何读取时发生的错误。即使 Read 返回的
	n < len(p)，方法也可能使用所有 p 的空间存储数据。如果数据可以读取，但是字节长度不足 len(p)，习惯上 Read 会立刻返回可用
	的数据，而不等待更多的数据。

2.	当成功读取 n > 0 字节后，如果遇到错误或者文件读取完成，Read 方法会返回读入的字节数。方法可能会在本次调用返回一个非 nil 的
	错误，或者在下一次调用时返回错误（同时 n == 0）。这种情况的一个例子是，在输入的流结束时，Read 会返回非零的读取字节数，可
	能会返回 err == EOF，也可能会返回 err == nil。无论如何，下一次调用 Read 应该返回 0, EOF。

3.	调用者在返回的 n > 0 时，总应该先处理读入的数据，再处理错误 err。这样才能正确操作读取一部分字节后发生的 I/O 错误。EOF 也
	要这样处理。

4.	Read 的实现不鼓励返回 0 个读取字节的同时，返回 nil 值的错误。调用者需要将这种返回状态视为没有做任何操作，而不是遇到读取结束。
```

标准库里列出了实现 Read 方法的 4 条规则。第一条规则表明，该实现需要试图读取数据来填满被传入的 byte 切片。允许出现读取的字节
小于 byte 切片的长度，并且如果在读取时已经读到数据但是数据不足以填满 byte 切片时，不应该等待新数据，而是要直接返回已读数据。

第二条规则提供了应该如何处理达到文件末尾(EOF)的情况的指导。当读到最后一个字节时，可以有两种选择。一种是 Read 返回最终读到的
字节数，并且返回 EOF 作为错误值，另一种是返回最终读到的字节数，并返回 nil 作为错误值。在后一种情况下，下一次读取的时候，由于
没有更多的数据可供读取，需要返回 0 作为读到的字节数，以及 EOF 作为错误值。

第三条规则是给调用 Read 的人的建议。任何时候 Read 返回了读取的字节数，都应该优先处理这些读取到的字节，再去检查 EOF 错误值或者
其他错误值。最终，第四条约束建议 Read 方法的实现永远不要返回 0 个读取字节的同时返回 nil 作为错误值。如果没有读到值，Read 应该
总是返回一个错误。

### 整合并完成工作

[listing37.go](listing37.go)

这个程序使用了标准库的 3 个包来将"Hello World!"输出到终端窗口。一开始，程序声明了 bytes.Buffer 类型的变量，并使用零值初始化。
创建了 byte 切片，并且字符串"Hello"初始化了这个切片。byte 切片随后被传入了 Write 方法，成为 Buffer 类型变量里的初始内容。
接着，Fprintf 将字符串"World!"追回到 Buffer 类型变量里，这意味着 Buffer 类型必须实现了接口 io.Writer。最后，WriteTo 方法把
Buffer 类型的变量写到 stdout 设备。

### 简单的 curl

在 Linux 和 MacOS 系统里可以找到一个名为 curl 的命令行工具。这个工具可以对指定的 URL 发起 HTTP 请求，并保存返回的内容。通过
使用 http、io 和 os 包，可以实现一个 curl 工具。

[listing46.go](listing46.go)

### 结论

可以在 io 包里找到大量的支持不同功能的函数，这些函数都能通过实现了 io.Writer 和 io.Reader 接口类型的值进行调用。其他包，如http
包，也使用类似的模式，将接口声明为包的 API 的一部分，并提供对 io 包的支持。应该花时间看一下标准库中提供了些什么，以及它是如何
实现的——不仅要防止重新造轮子，还要理解 Go 语言的设计者的习惯，并将这些习惯应用到自己的包和 API 的设计上。
