# 数组、切片和映射

Go 语言有 3 种数据结构可以让用户管理集合数据：数组、切片和映射。这 3 种数据结构是语言核心的一部分，在标准库里被广泛使用。

## 数组的内部实现和基础功能

了解这些数据结构，一般会从数组开始，因为数组是切片和映射的基础数据结构。理解了数组的工作原理，有助于理解切片和映射提供的优雅和强大的功能。

### 内部实现

在 Go 语言里，数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也
可以是某种结构类型。

下图中可以看到数组的表示。灰色格子代表数组里的元素，每个元素都紧邻另一个元素。每个元素包含相同的类型，这个例子里是整数，并且每个元素都可
以用一个唯一的索引（也称下标或标号）来访问。![WX20180403-094533.png](WX20180403-094533.png)

数组是一种非常有用的数据结构，因为其占用的内存是连续分配的。由于内存连续，CPU 能把正在使用的数据缓存更久的时间。而且内存连续很容易计算索
引，可以快速迭代数组里的所有元素。数组的类型信息可以提供每次访问一个元素时需要在内存中移动的距离。既然数组的每个元素类型相同，又是连续分
配，就可以以固定速度索引数组中的任意数据，速度非常快。

### 声明和初始化

声明数组时需要指定内部存储的数据的类型，以及需要存储的元素的数量，这个数量也称为数组的长度。

> 声明一个数组，并设置为零值

```
// 声明一个包含 5 个元素的整型数组
var array [5]int
```

一旦声明，数组里存储的数据类型和数组长度就都不能改变了。

在 Go 语言中声明变量时，总会使用对应类型的零值来对变量进行初始化。数组也不例外。当数组初始化时，数组内每个元素都初始化为对应类型的零值。

一种快速创建数组并初始化的方式是使用数组字面量。数组字面量允许声明数组里元素的数量同时指定每个元素的值。

> 使用数组字面量声明数组

```
// 声明一个包含 5 个元素的整型数组
// 用具体值初始化每个元素
array := [5]int{10, 20, 30, 40, 50}
```

如果使用`...`替代数组的长度，Go 语言会根据初始化时数组元素的数量来确定该数组的长度。

> 让 Go 自动计算声明数组的长度

```
// 声明一个整型数组
// 用具体值初始化每个元素
// 容量由初始化值的数量决定
array := [...]int{10, 20, 30, 40, 50}
```

如果知道数组的长度而且准备给每个值都指定具体值，就可以如下。

> 声明数组并指定特定元素的值

```
// 声明一个有 5 个元素的数组
// 用具体值初始化索引为 1 和 2 的元素
// 其余元素保持零值
array := [5]int{1: 10, 2: 20}
```

### 使用数组

因为内存布局是连续的，所以数组是效率很高的数据结构。在访问数组里任意元素的时候，这种高效都是数组的优势。要访问数组里某个单独元素，使用`[]`
运算符。

> 访问数组元素

```
// 声明一个包含 5 个元素的整型数组
// 用具体值初始为每个元素
array := [5]int{10, 20, 30, 40, 50}

// 修改索引为 2 的元素的值
array[2] = 35
```

声明一个所有元素都是指针的数组。使用`*`运算符访问元素指针指向的值。

> 访问指针数组的元素

```
// 声明包含 5 个元素的指向整数的数组
// 用整型指针初始化索引为 0 和 1 的数组元素
array := [5]*int{0: new(int), 1: new(int)}

// 为索引为 0 和 1 的元素赋值
*array[0] = 10
*array[1] = 20
```

在 Go 语言里，数组是一个值。这意味着数组可以用在赋值操作中。变量名代表整个数组，因此，同样类型的数组可以赋值给另一个数组。

> 把同样类型的一个数组赋值给另外一个数组

```
// 声明第一个包含 5 个元素的字符串数组
var array1 [5]string

// 声明第二个包含 5 个元素的字符串数组
// 用颜色初始化数组
array2 := [2]string{"Red", "Blue", "Green", "Yellow", "Pink"}

// 把 array2 的值复制到 array1
array1 = array2
```

复制之后，两个数组的值完全一样。数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能互相赋值。

复制数组指针，只会复制指针的值，而不会复制指针所指向的值。

> 把一个指针数组赋值给另一个

```
// 声明第一个包含 3 个元素的指向字符串的指针数组
var array1 [3]*string

// 声明第二个包含 3 个元素的指向字符串的指针数组
// 使用字符串指针初始化这个数组
array2 := [3]*string{new(string), new(string), new(string)}

// 使用颜色为每个元素赋值
*array[0] = "Red"
*array[1] = "Blue"
*array[2] = "Green"

// 将 array2 复制给 array1
array1 = array2
```

复制之后，两个数组指向同一个组字符串。

### 多维数组

数组本身只有一个维度，不过可以组合多个数组创建多维数组。多维数组很容易管理具有父子关系的数据或者与坐标系相关联的数据。

> 声明二维数组

```
// 声明一个二维整型数组，两个维度分别存储 4 个元素和 2 个元素
var array [4][2]int

// 使用数组字面量来声明并初始化一个二维整型数组
array := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}

// 声明并初始化外层数组中索引为 1 和 3 的元素
array := [4][2]{1: {20, 31}, 3: {40, 41}}

// 声明并初始化外层数组和内层数组的单个元素
array := [4][2]int{1: {0: 20}, 3: {1: 41}}
```

> 访问二维数组的元素

为了访问单个元素，需要反复组合使用`[]`运算符。

```
// 声明一个 2X2 的二维整型数组
var array [2][2]int

// 设置每个元素的整型值
array[0][0] = 10
array[0][1] = 20
array[1][0] = 30
array[1][1] = 40
```

只要类型一致，就可以将多维数组互相赋值。多维数组的类型包括每一维度的长度以及最终存会在元素中的数据的类型。

> 同样类型的多维数组赋值

```
// 声明两个不同的二维整型数组
var array1 [2][2]int
var array2 [2][2]int

// 为每个元素赋值
array2[0][0] = 10
array2[0][1] = 10
array2[1][0] = 10
array2[1][1] = 10

// 将 array2 的值复制给 array1
array1 = array2
```

因为每个数组都是一个值，所以可以独立复制某个维度。

> 使用索引为多维数组赋值

```
// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里
var array3 [2]int = array[1]

// 将外层数组的索引为 1、内层数组的索引为 0 的整型值复制到新的整形变量里
var value int = array[1][0]
```

### 在函数间传递数组

根据内存和性能来看，在函数间传递数组是一个开销很大的操作。在函数之间传递变量时，总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，
不管有多长，都会完整复制，并传递给函数。

为了考察这个操作，创建一个包含 100 万个 int 类型元素的数组。在 64 位架构上，需要 800 万字节，即 8MB 内存。如果声明了这种大小的数组，并将其
传递给函数，会发生什么呢？

> 使用值传递，在函数间传递大数组

```
// 声明一个需要 8MB 的数组
var array [1e6]int

// 将数组传递给函数 foo
foo(array)

// 函数 foo 接受一个 100 万个整型值的数组
func foo(array [1e6]int) {
	...
}
```

每次函数 foo 被调用时，必须在栈中分配 8MB 的内存。之后，整个数组的值（8MB 的内存）被复制到刚分配的内存里。虽然 Go 语言自己会处理这个复制操作，
不过还有一种更好且更有效的方法来处理这个操作。可以只传入指向数组的指针，这样只需要复制 8 字节的数据而不是 8MB 的内存数据到栈上。

> 使用指针在函数间传递大数组

```
// 分配一个需要 8MB 的数组
var array [1e6]int

// 将数组的地址传递给函数 foo
foo(&array)

// 函数 foo 接受一个指向 100 万个整型值的数组的指针
func foo(array *[1e6]int) {
	...
}
```

这次函数接受一个指向 100 万个整型值的数组的指针。现在将数组的地址传入函数，只需要在栈上分配 8 字节的内存给指针就可以。

这个操作会更有效地利用内存，性能也更好。不过要意识到，因为现在传递的是指针，所以如果改变指针指向的值，会改变共享的内存。

## 切片的内部实现和基础功能

**切片**是一种数据结构，这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置
函数 append 来实现的。这个函数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的底层内存也是在连续块中分配的，
所以切片还能获得索引、迭代以及为垃圾回收优化的好处。

### 内部实现

切片是一个很小的对象，对底层数组进行了抽象，并提供相关的操作方法。切片有 3 个字段的数据结构，这些数据结构包含 Go 语言需要操作底层数组的元数
据（见下图）。![WX20180403-113532.png](WX20180403-113532.png)

这 3 个字段分别是指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素个数（即容量）。

### 创建和初始化

Go 语言中有几种方法可以创建和初始化切片。是否能提前知道切片需要的容量通常会决定要如何创建切片。

1.	**make 和切片字面量**: 一种创建切片的方法是使用内置的 make 函数。当使用 make 时，需要传入一个参数，指定切片的长度。

	> 使用长度声明一个字符串切片

	```
	// 创建一个字符串切片
	// 其长度和容量都是 5 个元素
	slice := make([]string, 5)
	```

	如果只指定长度，那么切片的容量和长度相等。

	> 使用长度和容量声明整形切片

	```
	// 创建一个整型切片
	// 其长度为 3 个元素，容量为 5 个元素
	slice := make([]int, 3, 5)
	```

	分别指定长度和容量时，创建的切片，底层数组的长度是指定的容量，但初始化后并不能访问所有的数组元素。以上代码中的切片可以访问 3 个元素，而
	底层数组拥有 5 个元素。剩余的 2 个元素可以在后期操作中合并到切片，可以通过切片访问这些元素。如果基于这个切片创建新的切片，新切片会和原
	有切片共享底层数组，也能通过后期操作来访问多余容量的元素。

	不允许创建容量小于长度的切片。

	另一种常用的创建切片的方法是使用切片字面量。这种方法和创建数组类似，只是不需要指定`[]`运算符里的值。初始的长度和容量会基于初始化时提供的
	元素的个数确定。

	> 通过切片字面量来声明切片

	```
	// 创建字符串切片
	// 其长度和容量都是 5 个元素
	slice := []string{"Red", "Blue", "Green", "Yellow", "Pink"}

	// 创建一个整型切片
	// 其长度和容量都是 3 个元素
	slice := []int{10, 20, 30}
	```

	当使用切片字面量时，可设置初始长度和容量。要做的就是在初始化时给出所需的长度和容量作为索引。	

	> 使用索引声明切片

	```
	// 创建字符串切片
	// 使用空字符串初始化第 100 个元素
	slice := []string{99: ""}
	```

	如果在`[]`运算符里指定了一个值，那么创建的就是数组而不是切片。只有不指定值的时候，才会创建切片。

	> 声明数组和声明切片的不同

	```
	// 创建有 3 个元素的整型数组
	array := [3]int{10, 20, 30}

	// 创建长度和容量都是 3 的整型切片
	slice := []int{10, 20, 30}
	```

2.	**nil 和空切片**: 有时，程序可能需要声明一个值为 nil 的切片（也称 nil 切片）。只要在声明时不做任何初始化，就会创建一个 nil 切片。

	> 创建 nil 切片

	```
	var slice []int
	```

	在 Go 语言里，nil 切片是很常见的创建切片的方法。nil 切片可以用于很多标准库和内置函数。在需要描述一个不存在的切片时，nil 切片会很好用。
	例如，函数要求返回一个切片但是发生异常的时候（见下图）。![WX20180403-122426.png](WX20180403-122426.png)

	利用初始化，通过声明一个切片可以创建一个空切片。

	> 声明空切片

	```
	// 使用 make 创建空的整型切片
	slice := make([]int, 0)

	// 使用切片字面量创建空的整型切片
	slice := []int{}
	```

	空切片在底层数组包含 0 个元素，也没有分配任何存储空间。想表示空集合时空切片很有用，例如，数据库查询返回 0 个查询结果时（如下图）。![WX20180403-122812.png](WX20180403-122812.png)

	不管是使用 nil 切片还是空切片，对其调用内置函数 append、len 和 cap 的效果都是一样的。

### 使用切片

1.	**赋值和切片**: 对切片里某个索引指向的元素赋值和对数组里某个索引指向的元素赋值的方法完全一样。

	> 使用切片字面量来声明切片

	```
	// 创建一个整型切片
	// 其容量和长度都是 5 个元素
	slice := []int{10, 20, 30, 40, 50}

	// 改变索引为 1 的元素的值
	slice[1] = 25
	```

	切片之所以被称为切片，是因为创建一个新的切片就是把底层数组切出一部分。

	> 使用切片创建切片

	```

	```
