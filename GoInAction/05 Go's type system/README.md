# Go 语言的类型系统

Go 语言是一种静态类型的编程语言。这意味着，编译器需要在编译时知晓程序里每个值的类型。如果提前知道类型信息，编译器就可以确保程序合理地使用值。
这有助于减少潜在的内存异常和 bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。

值的类型给编译器提供两部分信息：第一部分，需要分配多少内存给这个值（即值的规模）；第二部分，这段内存表示什么。对于许多内置类型的情况来说，规
模和表示是类型名的一部分。

## 用户定义的类型

Go 语言允许用户定义类型。当用户声明一个新类型时，这个声明就给编译器提供了一个框架，告知必要的内存大小和表示信息。声明后的类型与内置类型的运作
方式类似。Go 语言里声明用户定义的类型有两种方法。最常用的方法是使用关键字 struct，它可以让用户创建一个结构类型。

> 声明一个结构类型

```
type user struct {
	name		string
	email		string
	ext			int
	privileged	bool
}
```

可以看到，这个结构类型的声明以关键字 type 开始，之后是新类型的名字，最后是关键字 struct。

> 使用结构类型声明变量，并初始化为其零值

```
// 声明 user 类型的变量
var bill user
```

关键字 var 创建了类型为 user 且名为 bill 的变量。当声明变量时，这个变量对应的值总是会被初始化。这个值要么用指定的值初始化，要么用零值（即变量
类型的默认值）做初始化。

还可以使用短变量声明操作符。这个操作符是冒号加一个等号`:=`。一个短变量声明操作在一次操作中完成两件事情：声明一个变量，并初始化。短变量声明操作
符会使用右侧给出的类型信息作为声明变量的类型。

> 使用结构字面量来声明一个结构类型的变量

```
// 声明 user 类型的变量，并初始化所有字段
lisa := user{
	name: "Lisa",
	email: "lisa@email.com",
	ext: 123,
	privileged: true,
}
```

结构字面量可以对结构类型采用两种形式。以上形式在不同行声明每个字段的名字以及对应的值。字段名与值用冒号分隔，每一行以逗号结尾。这种形式对字段
的声明顺序没有要求。第二种形式没有字段名，只声明对应的值。

> 不使用字段名，创建结构类型的值

```
lisa := user{"Lisa", "lisa@email.com", 123, true}
```

这种形式下，值的顺序很重要，必须要和结构声明中字段的顺序一致。当声明结构类型时，字段的类型并不限制在内置类型，也可以使用其他用户定义的类型。

> 使用其他结构类型声明字段

```
// admin 需要一个 user 类型作为管理者，并附加权限
type admin struct {
	person user
	level string
}
```

以上代码展示了一个名为 admin 的新结构类型。这个结构类型有一个名为 person 的 user 类型的字段，还声明了一个名为 level 的 string 字段。当创建具
有 person 这种字段的结构类型的变量时，初始化用的结构字面量会有一些变化。

> 使用结构字面量来创建字段的值

```
// 声明 admin 类型的变量
fred := admin{
	person: user{
		name: "Lisa",
		email: "lisa@email.com",
		ext: 123,
		privileged: true,
	},
	level: "super",
}
```

为了初始化 person 字段，需要创建一个 user 类型的值。

另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明。标准库使用这种声明类型的方法，从内置类型创建出很多更加明确的
类型，并赋予更高级的功能。

> 基于 int64 声明一个新类型

```
type Duration int64
```

以上展示的是标准库的 time 包里的一个类型的声明。Duration 是一种描述时间间隔的类型，单位是纳秒(ns)。这个类型使用内置的 int64 类型作为表示。
在 Duration 类型的声明中，我们把 int64 类型叫作 Duration 的基础类型。不过，虽然 int64 是基础类型，Go 并不认为 Duration 和 int64 是同一种类型。
这两个类型是完全不同的有区别的类型。换句话说，虽然 int64 类型是基础类型，Duration 类型依然是一个独立的类型。两种不同类型的值即使互相兼容，也不
能互相赋值。编译器不会对不同类型的值做隐式转换。

## 方法

方法能给用户定义的类型添加新的行为。方法实际上也是函数，只是在声明时，在关键字 func 和方法名之间增加了一个参数。

[listing11.go](listing11.go)

以上代码展示了两种类型的方法。关键字 func 和函数名之间的参数被称作**接收者**，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就
被称为**方法**。

Go 语言里有两种类型的接收者：**值接收者**和**指针接收者**。如果使用值接收者声明方法（[listing11.go](listing11.go)的第 15 行），调用时会使用
这个值的一个副本来执行。调用方法的语法与调用一个包里的函数看起来很类似（[listing11.go](listing11.go)的第 32 行）。在调用 notify 方法时，使用
bill 的值作为接收者进行调用，方法 notify 会接收到 bill 的值的一个副本。

也可以使用指针来调用使用值接收者声明的方法（[listing11.go](listing11.go)的第 37 行）。为了支持这种方法调用，Go 语言调整了指针的值，来符合方法
接收者的定义。可以认为 Go 语言执行了以下代码所示的操作。

> Go 在代码背后的执行操作

```
*(lisa).notify()
```

以上代码展示了 Go 编译器为了支持这种方法调用背后做的事情。指针被解引用为值，这样就符合了值接收者的要求。同样的，notify 操作的也是一个副本。

也可以使用指针接收者声明方法（[listing11.go](listing11.go)的第 23 行）。这个接收者的类型是指向 user 类型值的指针，而不是 user 类型的值。当调
用使用指针接收者声明方法时，这个方法会共享调用方法时接收者所指向的值（[listing11.go](listing11.go)的第 36 行）。

**值接收者使用值的副本来调用方法，而指针接收者使用实际值来调用方法。**

也可以使用一个值来调用使用指针接收者声明的方法（[listing11.go](listing11.go)的第 41 行）。Go 语言再一次对值做了调整，使之符合函数的接收者，
进行调用。

> Go 在代码背后的执行动作

```
(&bill).changeEmail("bill@newdomain.com")
```

以上代码展示了 Go 编译器为了支持这种方法调用在背后做的事情。首先引用 bill 值得到一个指针，这样这个指针就能够匹配方法的接收者类型，再进行
调用。Go 语言既允许使用值，也允许使用指针来调用方法，不必严格符合接收者的类型。

## 类型的本质

类型的本质是什么？

如果给这个类型增加或者删除某个值，是要创建一个新值，还是要更改当前的值？如果是要创建一个新值，该类型的方法就使用值接收者。如果是要修改当
前值，就使用指针接收者。这个答案也会影响程序内部传递这个类型的值的方式：是按值做传递，还是按指针做传递。保持传递的一致性很重要。这个背后的
原则是，不要只关注某个方法是如何处理这个值，而是要关注这个值的本质是什么。

### 内置类型

内置类型是由语言提供的一组类型，分别有数值类型、字符串类型和布尔类型。这些类型本质上是原始的类型。因此，当对这些值进行增加或者删除时，会
创建一个新值。基于这个结论，当把这些类型的值传递给方法或者函数时，应该传递一个对应值的副本。来看一下标准库里使用这里内置类型的值的函数。

> golang.org/src/strings/strings.go

```
func Trim(s string, cutset string) string {
	if s == "" || cutset == "" {
		return s
	}
	return TrimFunc(s, makeCutsetFunc(cutset))
}
```

Trim 函数对调用者原始的 string 值的一个副本做操作，并返回一个新的 string 值的副本。字符串(string)就像整数、浮点数和布尔值一样，本质上是一
种很原始的数据值，所以在函数或方法内外传递时，要传递字符串的一份副本。

再看一下体现内置类型具有的原始本质的第二个例子。

> golang.org/src/os/env.go

```
func isShellSpecialVar(c uint8) bool {
	switch c {
		case '*', '#', '$', '@', '!', '?', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			return true
	}
	return false
}
```

这里的参数没有使用指针来共享参数的值或者返回值。调用者传入了一个 uint8 值的副本，并接受一个返回值 true 或者 false。

### 引用类型

Go 语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称作**标头(header)**值。从技术细节上
说，字符串也是一种引用类型。每个引用类型创建的标头值是包含一个指向底层数据结构的指针。每个引用类型还包含一组独特的字段，用于管理底层数据
结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用类型的值。标头值里包含一个指针，因此通过复制来传递一个引用类型的值的副本，本
质上就是在共享底层数据结构。

来看一下 net 包里的类型。

> golang.org/src/net/ip.go

```
type IP []byte
```

以上代码展示了一个名为 IP 的类型，这个类型被声明为字节切片。当要围绕想着的内置类型或者引用类型来声明用户定义的行为时，直接基于已有类型来
声明用户定义的类型会很好用。编译器只允许为全名的用户定义的类型声明方法。

> golang.org/src/net/ip.go

```
func (ip IP) MarchalText() ([]byte, error) {
	if len(ip) == 0 {
		return []byte(""), nil
	}
	if len(ip) != IPv4len && len(ip) != IPv6len {
		return nil, errors.New("invalid IP address")
	}
	return []byte(ip.String()), nil
}
```

MarshalText 方法是用 IP 类型的值接收者声明的。一个值接收者，正如预期的通过复制来传递引用，从而不需要通过指针来共享引用类型的值。这种传递
方法也可以应用到函数或者方法的参数传递。

> golang.org/src/net/ip.go

```
// ipEmptyString 像 ip.String 一样，
// 只不过在没有设置 ip 时会返回一个空字符串
func ipEmptyString(ip IP) string {
    if len(ip) == 0 {
        return "" 
    }
    return ip.String()
}
```

这个函数需要传入一个 IP 类型的值。再一次，可以看到调用者传入的是这个引用类型的值，而不是通过引用共享给这个函数。调用者将引用类型的值的副本传入
这个函数。最后要说的是，引用类型的值在其他方面像原始的数据类型的值一样对待。

### 结构类型

结构类型可以用来描述一组数据值，这组值的本质即可以是原始的，也可以是非原始的。

> golang.org/src/time/time.go

```go
type Time struct {
	// sec 给出自公元 1 年 1 月 1 日 00:00:00
	// 开始的秒数
	sec int64
	
	// nsec 指定了一秒内的纳秒偏移
	// 这个值是非零值
	// 必须在 [0, 999999999] 范围内
	nsec int32
	
	// loc 指定了一个 Location，
	// 用于决定该时间对应的当地的分、小时、
	// 天和年的值
	// 只有 Time 的零值，其 loc 的值是 nil
	// 这种情况下，认为处于 UTC 时区
	loc *Location
}
```


