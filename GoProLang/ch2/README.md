### 程序结构

Go 语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基础类型
被聚合为数组或结构体等更复杂的数据结构。然后使用 if 和 for 之类的控制语句来组织和控制表达式的执行流程。然后多个语句被组织到一个个函
数中，以便代码的隔离和复用。函数以源文件和包的方式被组织。

> 命名

Go 语言中的所有命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode 字母）或下划线开头，后面可以跟任意数量的字母、数字或
下划线 。大写字母和小写字母是不同的。在习惯上，Go 语言程序员推荐使用驼峰式命名，而像 HTML 这种缩略词则避免使用大小写混合的写法。


> 声明

声明语句定义了程序的各种实体对象以及部分或全部的属性。Go 语言主要有四种类型的声明语句：var、const、type 和 func，分别对应变量、常量、
类型和函数实体对象的声明。

一个 Go 语言编写的程序对应一个或多个以 .go 为文件后缀名的源文件中。每个源文件以包的声明语句开始，说明该源文件是属于哪个包。包声明
语句之后是 import 语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要
（译注：函数内部的名字则必须先声明之后才能使用）。

[boiling.go](demo/boiling.go)

以上例子中声明了一个常量、一个函数和两个变量。其中常量 boilingF 是在包一级范围声明的，然后 f 和 c 两个变量是在 main 函数内部的声明
语句声明的。在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不仅仅在其声明语句所在的源文件中访问。相比之下，局部声明
的名字就只能在函数内部很小的范围被访问。

一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。如果
函数没有返回值，那么返回值列表是省略的。

[ftoc.go](demo/ftoc.go)


> 变量

var 声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：

```
var 变量名字 类型 = 表达式
```

其中"类型"或"= 表达式"两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式
省略，那么将用零值初始化该变量。数值类型变量对应的零值是 0，布尔类型变量对应的零值是 false，字符串类型对应的零值是空字符串，接口或
引用类型（包括 slice、指针、map、chan 和函数）变量对应的零值是 nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型
的零值。

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在 Go 语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以
在没有增加额外工作的前提下确保边界条件下的合理行为。如：

```
var s string
fmt.Println(s)  // ""
```

这段代码将打印一个空字符串，而不是导致错误或产生不可预知的行为。

也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同
的变量（类型由初始化表达式推导）：

```
var i, j, k int  // int , int, int
var b, f, s = true, 2.3, "four"  // bool, float64, string
```

初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在 main 入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候
完成初始化。

>> 简短变量声明

在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来
自动推导。和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：

```
i, j := 0, 1
```

有一个比较微妙的地方：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语
句对这些已经声明过的变量就只有赋值行为了。但是注意，简短变量声明语句中必须至少要声明一个新的变量，以下代码将 **不能编译通过**：

```
f, err := os.Open(infile)
f, err := os.Create(outfile)  // compile error: no new variables
```

简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前
词法域重新声明一个新的变量。

>> 指针

一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫 x 的变量，但是还有很多变量始终以表
达式方式引入，例如 x[i] 或 x.f 变量。所有这些表达式一般都是读取一个变量的值，除非它们是出现在赋值语句的左边，这种时候是给对应变量赋
予一个新的值。

一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内
存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。Go 的指针与 C 语言类似。

```
x := 1
p := &x  // p, of type *int, points to x
fmt.Println(*p)  // 1
*p = 2  // equivalent to x = 2
fmt.Println(x)  // 2
```

对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。

变量有时候也被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受 & 取地址操作。

任何类型的指针的零值都是 nil。

在 Go 语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用 f 函数时创建局部变量 v，在局部变量地址被返回之后
依然有效，因为指针 p 依然引用这个变量。

```
var p = f()

func f() *int {
    v := 1
    return &v
}
```

每次调用 f 函数都将返回不同的结果：

```
fmt.Println(f() == f())  // false
```

历为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。例如下面这个例子
就是通过指针来更新变量的值，然后返回更新后的值，可用在一个表达式中（译注：这是对 C 语言中 ++v 操作的模拟，这里只是为了
说明指针的用法，incr 函数模拟的做法并不推荐）：

```
func incr(p *int) int {
    *p ++  // 非常重要：只是增加 p 指向的变量的值，并不改变 p 指针
    return *p
}

v := 1
incr(&v)  // side effect: v is now 2
fmt.Println(incr(&v)) // 3 (and v is 3)
```

指针特别有价值的地方在于我们可以不用名字而访问一个变量，但这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变
量全部的别名（译注：这是 Go 语言的垃圾回收器所做的工作）。不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如 slice、
map 和 chan，甚至结构体、数组和接口都会创建所引用变量的别名。

指针是实现标准库中 flag 包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个
程序中。为了说明这一点，在早些的 echo 版本中，就包含了两个可选的命令行参数：-n 用于忽略行尾的换行符，-s sep 用于指定分隔
字符（默认是空格）。下面是第四个版本：

[echo4.go](demo/echo4.go)

调用 flag.Bool 函数会创建一个的对应布尔型标志参数的变量。它有三个属性：第一个是命令行标志参数的名字"n"，然后是该标志参数的
默认值（这里是 false），最后是该标志参数对应的描述信息。如果用户在命令行输入了一个无效的标志参数，或者输入 -h 或 -help 参
数，那么将打印所有标志参数的名字、默认值和描述信息。类似的，调用 flag.String 函数。程序中的 sep 和 n 变量分别是指向对应命
令行标志参数变量的指针，因此必须用 *sep 和 *n 形式的指针语法间接引用它们。

当程序运行时，必须在使用标志参数对应的变量之前先调用 flag.Parse 函数，用于更新每个标志参数对应变量的值（之前是默认值）。
对于非标志参数的普通命令参数可以通过调用 flag.Args() 函数来访问，返回值对应一个字符串类型的 slice。

>> new 函数

另一个创建变量的方法是调用内建的 new 函数。表达式 new(T) 将创建一个 T 类型的匿名变量，初始化为 T 类型的零值，然后返回变量
地址，返回的指针类型为 *T。

```
p := new(int)  / p, *int 类型，指向匿名的 int 变量
fmt.Println(*p)  // 0
*p = 2  // 设置 int 匿名变量的值为 2
fmt.Println(*p)  // 2
```

用 new 创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用 new(T)。
换言之，new 函数类似是一种语法糖，而不是一个新的基础概念。

每次调用 new 函数都是返回一个新的变量的地址，因此下面两个地址是不同的：

```
p := new(int)
q := new(int)
fmt.Println(p == q)  // false
```

当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是 0，例如 struct{} 和 [0]int，有可能有相同的地址（依
赖具体的语言实现）（译注：请谨慎使用大小为 0 的类型，因为如果类型的大小为 0 的话，可能导致 Go 语言的自动垃圾回收器有不
同的行为，具体请查看 runtime.SetFinalizer 函数相关文档）。

new 函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。由于 new 只是一个预定义的函数，
它并不是一个关键字，因此我们可以将 new 名字重新定义为别的类型，如下：

```
func delta(old, new int) int {
    return new - old
}
```

由于 new 被定义为 int 类型的变量名，因此在 delta 函数内部是无法使用内置的 new 函的。

>> 变量的生命周期

对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期则是动态的：
每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值
变量都是局部变量。它们在函数每次被调用的时候创建。

那么 Go 语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路
是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不
存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量
可能在函数返回之后依然存在。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用 var 还是 new 声明变
量的方式来决定的。

```
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

f 函数里的 x 变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的 global 变量找到，虽然它是在函数内部定义的；
用 Go 语言的术语说，这个 x 局部变量从函数 f 中逃逸了。相反，当 g 函数返回时，变量`*y`将是不可达的，也就是说可以马
上被回收的。因此，`*y`并没有从函数 g 中逃逸，编译器可以选择在栈上分配`*y`的存储空间（译注：也可以选择在堆上分配，然
后由 Go 语言回收这个变量的内存空间）。其实在任何时候，都并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃
逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。

Go 语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说完全不用考虑内存了。虽然不需要显式地分配和释放内存，
但是要编写高效的程序依然需要了解变量的生命周期。例如，如果将指向生命周期对象的指针保存到具有长生命周期的对象中，特别是保
存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。

> 赋值

使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在 = 的左边，新值的表达式放在 = 的右边。

```
x = 1  // 命名变量的赋值
*p = true  // 通过指针间接赋值
person.name = "bob"  // 结构体字段赋值
count[x] = count[x] * scale  // 数组、slice 或 map 的元素赋值
```

特定的二元算术运算符和赋值语句的复合操作有一个简洁形式，例如上面最后的语句可以重写为：

```
count[x] *= scale
```

这样可以省去对变量表达式的重复计算。

数值变量也可以支持 ++ 递增和 -- 递减语句（译注：自增和自减是语句，而不是表达式，因此 x = i ++ 之类的表达式是错误的）：

```
v := 1
v ++  // 等价方式 v = v + 1; v 变成 2
v --  // 等价方式 v = v - 1; v 变成 1
```

>> 元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一
更新左边对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如可以这样交换两个变量的值：

```
x, y = y, x
a[i], a[j] = a[j], a[i]
```

或者是计算两个整数值的最大公约数(GCD, greatest common divisor)：

```
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x % y 
    }
}
```

或者是计算斐波纳契数列(Fibonacci)的第 N 个数：

```
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i ++ {
        x, y = y, x + y 
    }
    return x
}
```

和变量声明一样，也以以用下划线空折标识符`_`来丢弃不需要的值。

```
_, ok = io.Copy(dst, src)  // 丢弃字节数
```

>> 可赋值性

赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回
语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。

```
medals := []string{"gold", "silver", "bronze"}
```

隐式地对 slice 的每个元素进行赋值操作，类似这样写的行为：

```
medals[0] = "gold"
medals[1] = "silver"
medals[2] = "bronze"
```

map 和 chan 的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。


> 类型

变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的 bit 个数），它们在内部是如何表达的，是否支持
一些操作符，以及它们自己关联的方法集等。

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即
使它们底层类型相同也是不兼容的。

```
type 类型名字 底层类型
```

类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用。

[tempconv0.go](demo/tempconv0.go)

在以上代码中的包声明了两种类型：Celsius 和 Fahrenheit 分别对应不同的温度单位。它们虽然有着相同的底层类型  float64，但是它们是
不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致
的错误；因此需要一个类似 Celsius(t) 或 Fahrenheit(t) 形式的显式转型操作才能将 float64 转为对应的类型。Celsius(t) 和 Fahrenheit(t) 
是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。


> 包和文件

Go 语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以
`.go`为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径：例如包`gopl.io/ch1/helloworld`对应的目录路径是
`$GOPATH/src/gopl.io/ch1/helloworld`。

每个包都对应一个独立的名字空间。包可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在 Go 语言中，一个简单的规则是：
如果一个名字是大写字母开头的，那么该名字可导出的。

以下创建一个名为`tempconv`的包，这是前面例子的一个改进版本。包代码存储在两个源文件中，用来演未如何在一个源文件声明然后在其他的
源文件访问；虽然在现实中，这样小的包一般只需要一个文件。

[tempconv](demo/tempconv)

每个源文件都是以包的声明语句开始，用来指明包的名字。当包被导入的时候，包内的成员将通过类似`tempconv.CToF`的形式访问。而包级别的名字，
例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。

因为包级别的常量名都是以大写字母开头，它们可以像`tempconv.AbsoluteZeroC`这样被外部代码访问：

```go
fmt.Println("Brrrr! %v\n", tempconv.AbsoluteZeroC)  // "Brrrr! -273.15℃
```

要将摄氏温度转换为华氏温度，需要先用 import 语句导入包，然后就可以使用了。

在每个源文件的包声明前紧跟着的注释是包注释。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（
译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的
doc.go 文件中。

>> 导入包

在 Go 语言程序中，每个包都是有一个全局唯一的导入路径。导入语句类似`gopl.io/ch2/tempconv`的字符串对应包的导入路径。Go 语
言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用 Go 语言自带的 go 工具箱时，一个导入路径
代表一个目录中的一个或多个 Go 源文件。

除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字
和包的导入路径的最后一个字段相同，例如`gopl.io/ch2/tempconv`包的名字一般是`tempconv`。当然，我们了可以绑定到另一个名字，以
避免名字冲突。

[cf.go](demo/cf.go)

如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。这种强制规则可以有效减少不必要的依赖，虽然在调试期间可能会让人讨厌，
因为删除一个类似 log.Print("got here!") 的打印语句可能导致需要同时删除 log 包导入声明，否则，编译器将会发生一个错误。在这种
情况下，需要将不必要的导入删除或注释掉。

不过有更好的解决方案，我们可以使用 golang.org/x/tools/cmd/goimports 导入工具，它可以根据需要自动添加或删除导入的包；许多编
辑器都可以集成 goimports 工具，然后在保存文件的时候自动运行。类似的还有 gofmt 工具，可以用来格式化 Go 源文件。

>> 包的初始化

包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：

```go
var a = b + c  // a 第三个初始化，为 3
var b = f()    // b 第二个初始化，为 2，通过调用 f（依赖 c）
var c = 1      // c 第一个初始化，为 1

func f() { return c + 1 }
```

如果包中含有多个`.go`源文件，它们将按照发给编译器的顺序进行初始化，Go 语言的构建工具首先会将`.go`文件根据文件名顺序，
然后依次调用编译器编译。

对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个
简单的赋值过程。在这种情况下，可以用一个特殊的 init 初始化函数来简化初始化工作。每个文件都可以包含多个 init 初始化函数。

```go
func init() {
	/* ... */
}
```

这样的 init 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的 init 初始化函数，在程序开始执行时按
照它们声明的顺序被自动调用。

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个 p 包导入了 q 包，那么在 p 包初始
化的时候可以认为 q 包必然已经初始化过了。初始化工作是自下而上进行的，main 包最后被初始化。以这种方式，可以确保在 main 函
数执行之前，所有依赖的包都已经完成初始化工作了。

[popcount.go](demo/popcount.go)

> 作用域

一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。

声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间
区域内它可以被程序的其他部分引用；是一个运行时的概念。

句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的。可以把块(block)
的概念推广到其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法
块，称为全局词法块；对于每个包、每个 for、if 和 switch 语句，也都对应词法块；每个 switch 或 select 的分支也有独立的词法块。
