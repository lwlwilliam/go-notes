### 基础数据类型

Go 语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。

> 整型

Go 语言同时提供了有符号和无符号类型的整数运行。这里有 int8、int16、int32、int64 四种截然不同大小的有符号整数类型、分别对
应 8、16、32、64bit 大小的有符号整数，与此对应的是 uint8、uint16、uint32、uint64 四种无符号整数类型。

这里还有两种一般对应特定 CPU 平台机器字大小的有符号和无符号整数 int 和 uint；其中 int 是应用最广泛的数值类型。这两个类型都有同样
的大小，32 或 64bit，但是我们不能对此做任何假设；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。

Unicode 字符 rune 类型是和 int32 等价的类型，通常用于表示一个 Unicode 码点。这两个名称可以互换使用。同样 byte 也是 uint8 类型的
等价类型，byte 类型一般用于强调数值是一个原始的数据而不是一个小的整数。

最后，还有一种无符号的整数类型 uintptr，没有指定具体的 bit 大小但是足以容纳指针。uintptr 类型只有在底层编程时才需要，特别是 Go 语
言和 C 语言函数库或操作系统接口相交互的地方。

不管它们的具体大小，int、uint 和 uintptr 是不同类型的兄弟类型。其中 int 和 int32 也是不同的类型，即使 int 的大小也是 32 bit，在
需要将 int 当作 int32 类型的地方需要一个显式的类型转换操作，反之亦然。

其中有符号整数采用 2 的补码形式表示，也就是最高 bit 位用来表示符号位。

一般来说，需要一个的转换将一个值从一种类型转化为另一种类型，并且算术和逻辑运算的二元操作中必须是相同的类型。

在很多场景下，会遇到类似下面的代码能用的错误：

```go
var apples int32 = 1
var oranges int16 = 2
var compote int = apples + oranges // compile error
```

当尝试编译以上代码时，将产生一个错误信息：`invalid operation: apples + oranges (mismatched types int32 and int16)`。
这种类型不匹配的问题可以有几种不同的方法修复，最常见方法是将它们都显式转型为一个常见类型：

```go
var compote = int(apples) + int(oranges)
```

对于每种类型 T，如果转换允许的话，类型转换操作 T(x) 将 x 转换为 T 类型。

> 浮点数

Go 语言提供了两种精度的浮点数，float32 和 float64。

下面程序演示了通过浮点计算生成的图形。

[surface.go](surface.go)

> 复数

Go 语言提供了两种精度的复数类型：complex64 和 complex128，分别对应 float32 和 float64 两种浮点数精度。内置的 complex 函数用于构建
复数，内建的 real 和 imag 函数分别返回复数的实部和虚部。

```go
var x complex128 = complex(1, 2)  // 1 + 2i
var y complex128 = complex(3, 4)  // 3 + 4i
fmt.Println(x * y)  // "(-5+10i)"
fmt.Println(real(x * y)  // "-5"
fmt.Println(imag(x * y)  // "10"
```

在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像 1 + 2i 或与之
等价的写法 2i + 1。因此，以上 x 和 y 的声明语句还可以简化：

```go
x := 1 + 2i
y := 3 + 4i
```

下面程序使用 complex128 复数算法来生成一个 Mandelbrot 图像。

[mandelbrot.go](mandelbrot.go)

> 布尔型

一个布尔类型的值只有两种：true 和 flase。

> 字符串

一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括 byte 值 0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为
采用 UTF-8 编码的 Unicode 码点(rune)序列。

内置的 len 函数可以返回一个字符串中的字节数目（不是 rune 字符数目）索引操作 s[i] 返回第 i 个字节的字节值，i 必须满足`0 ≤ i ≤ len(s)`
条件约束。

```go
s := "hello, world"
fmt.Println(len(s))  // "12"
fmt.Println(s[0], s[7])  // "104 119" ('h' and 'w')
```

如果试图访问超出字符串索引范围的字节将会导致 panic 异常：`c := s[len(s)]  // panic: index out of range`。

第 i 个字节并不一定是字符串的第 i 个字符，因为对于非 ASCII 字符的 UTF8 编码会要两个或多个字节。先简单说说字符的工作方式。

子字符串操作 s[i:j] 基于原始的 s 字符串的第 i 个字节开始到第 j 个字节（并不包含 j 本身）生成一个新字符串。生成的新字符串将包含 j-i 个
字节。

```go
fmt.Println(s[0:5])  // "hello"
```

不管 i 还是 j 都可能被忽略，当它们被忽略时将采用 0 作为开始位置，采用 len(s) 作为结束的位置。

```go
fmt.Println(s[:5])  // "hello"
fmt.Println(s[7:])  // "world"
fmt.Println(s[:])  // "hello, world"
```

其中`+`操作符将两个字符串链接构造一个新字符串：

```go
fmt.Println("goodbye" + s[5:])  // "goodbye, world"
```

字符串可以用`==`和`<`进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。字符串的值是不可变的：一个字符串包含的
字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。可以像下面这样将一个字符串追回到另一个字符串：

```go
s := "left foot"
t := s
s += ", right foot"
```

这并不会导致原始的字符串值被改变，但是变量 s 将因为 += 语句持有一个新的字符串值，但是 t 依然是包含原先的字符串值。因为字符串是不可修改
的，因为尝试修改字符串内部数据的操作也是被禁止的：`s[0] = 'L'  // compile error: cannot assign to s[0]`。

不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串 s 和对应的子字符串切
片 s[7:] 的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。下图演示了一个字符串
和两个子串共享相同的底层数据。

![string](WX20180223-121731.png)

>> 字符串面值

字符串面值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号即可：`Hello, 世界`。因为 Go 语言源文件总是用 UTF8 编码，并且 Go 
语言的文本字符串也以 UTF8 编码的方式处理，因此我们可以将 Unicode 码点也写到字符串面值中。在一个双引号包含的字符串面值中，可以用以反斜
杠`\`开头的转义序列插入任意的数据。

一个原生的字符串面值形式是 **\`...\`**，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和
换行，因此一个程序中的原生字符串面值可能跨越多行（注：在原生字符串面值内部是无法直接写 **\`** 字符的，可以用八进制或十六进制转义或加链
接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也 放入文本文件的系统。

>> Unicode

>> UTF-8

>> 字符串和 Byte 切片

>> 字符串和数字的转换

> 常量

常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string 或数字。

一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。既可以单独声明，也可
以批量声明多个常量。

```go
const pi_one = 3.14159

const (
    e = 2.718
    pi = 3.14
)
```

所有常量的运行都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。

常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、
complex 和 unsafe.Sizeof。

因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：

```go
const IPv4Len = 4

// parseIPv4 parses an IPv4 address (d.d.d.d).
func parseIPv4(s string) IP {
    var p[IPv4Len]byte
    //...
}
```

一个常量的声明也可以包含一个类型和一个值，如果没有显式指明类型，那么将从右边的表达式推断类型。如果是批量声明的常量，除了第一个外其它的常
量右边的初始化表达式都可以省略，如果省略的初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样。

```go
const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d)  // "1 1 2 2"
```

如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是 iota 常量生成器语法。

>> iota 常量生成器

常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，
在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。

下面是来自 time 包的例子，它首先定义了一个 Weekday 命名类型，然后为一周的每天定义了一个常量，从周日 0 开始。在其它编程语言中，这种类型
一般被称为枚举类型。

```go
type Weekday int

const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```

```go
type Flags uint

const (
    FlagUp Flags = 1 << iota
    FlagBroadcast
    FlagLoopback
    FlagPointToPoint
    FlagMulticast
)
```

[netflag.go](netflag.go)

>> 无类型常量

Go 语言的常量有个不同寻常之处，许多常量并没有一个明确的基础类型。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运
算。这里有六种未明确类型的常量类型，分别是`无类型的布尔型`、`无类型的整数`、`无类型的字符`、`无类型的浮点数`、`无类型的复数`、`无类型的
字符串`。如下例：ZiB 和 YiB 的值已经超出任何 Go 语言中整数类型能表达的范围，但是它们依然是合法的常量，而且可以像下面常量表达式依然有效
（译注：YiB/ZiB 是在编译期计算出来的，并且结果常量是 1024，是 Go 语言 int 变量能有效表示的）：

```go
fmt.Println(YiB/ZiB)  // "1024"
```

另外，math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：

```go
var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
```

对于常量面值，不同的写法可能会对应不同的类型。例如 0、0.0、0i 和 \u0000 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮
点数、无类型的复数和无类型的字符串等不同的常量类型。同样，true 和 false 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。

