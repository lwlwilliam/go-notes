### 复合数据类型

基本数据类型可以用于构建程序中的数据结构，是 Go 语言世界的原子。这里主要讨论四种类型——数组、slice、map 和结构体。
数组和结构体是聚合类型；它闪的值由许多元素或成员字段的值组成。数组是由同构的元素组成——每个数组元素都是完全相同的类
型，结构体则是由异构的元素组成。数组和结构体都是有固定内存大小的数据结构。相比之下，slice 和 map 则是动态的数据结
构，它们将根据需要动态增长。

> 数组

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。和数组对应的类型是 Slice(切片)，它
是可以增长和收缩的动态序列，slice 功能也更灵活，但是要理解 slice 工作原理的话需要先理解数组。

默认情况下，数组的每个元素都被初始化为元素类型对应的零值。也可以使用数组字面值语法用一组值来初始化数组：

```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2])  // "0"
```

在数组字面值中，如果在数组的长度位置出现的是 **...** 省略号，则表示数组的长度是根据初始化值的个数来计算。

```go
q := [...]int{1, 2, 3}
fmt.Println("%T\n", q)  // "[3]int"
```

数组的长度是数组类型的一个组成部分，因此`[3]int`和`[4]int`是两种不同的数组类型。数组的长度必须是常量表达式，因为数
组的长度需要在编译阶段确定。

```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4}  // compile error: cannot assign [4]int to [3]int
```

以上的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化，如下：

```go
type Currency int

const (
	USD Currency = iota  // 美元
	EUR                  // 欧元
	GBP                  // 英镑
	RMB                  // 人民币
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}

fmt.Println(RMB, symbol[RMB])  // "3 ￥"
```

在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，未指定初始值的元素将用零值初始化。
如，

```go
r := [...]int{99: -1}
```

定义了一个含有 100 个元素的数组 r，最后一个元素被初始化为 -1，其它元素都是用 0 初始化。

如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候可以直接通过`==`比较运算符来比较。只有
两个数组的所有元素都是相等的时候数组才是相等的。

```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c)  // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d)  // compile error: cannot compare [2]int == [3]int
```

`crypto/sha256`包的 Sum256 函数对一个任意字节的 slice 类型的数据生成一个对应的消息摘要。消息摘要有 256bit 大小，
因此对应 [32]byte 数组类型。如果两个消息摘要是相同的，那么可以认为两个消息本身也相同（理论上有 HASH 码碰撞的情况，
但实际上可以基本忽略）。

[sha256](sha256.go)

> Slice

Slice(切片)代表变长的序列，序列中每个元素都有相同的类型。一个 slice 类型一般写作`[]T`，其中 T 代表 slice 中元素
的类型；slice 的语法和数组很像，只是没有固定长度而已。

数组和 slice 之间有着紧密的联系。一个 slice 是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而
且 slice 的底层确实引用一个数组对象。一个 slice 由三个部分构成：指针、长度和容量。指针指向第一个 slice 元素对应的
底层数组元素的地址，要注意的是 slice 的第一个元素并不一定就是数组的第一个元素。长度对应 slice 中元素的数目；长度不
能超过容量，容量一般是从 slice 的开始位置到底层数据的结尾位置。内置的 len 和 cap 函数分别返回 slice 的长度和容量。

多个 slice 之间可以共享底层的数据，并且引用的数组部分区间可能重叠。

数组这样定义：

```go
months := [...]string{1: "January", /* ... */, 12: "December"}
```

slice 的切片操作`s[i:j]`，其中`0<=i<=j<=cap(s)`，用于创建一个新的 slice，引用 s 的从第 i 个元素开始到第 j-1 
个元素的子序列。新的 slice 将只有 j-i 个元素。如果 i 位置的索引被省略的话将使用 0 代替，如果 j 位置的索引被省略的
话将使用 len(s) 代替。因此，months[1:13]切片操作将引用全部有效的月份，和 months[1:]操作等价；months[:]切片操
作则是引用整个数组。分别定义表示第二季度和北方夏天月份的 slice，它们有重叠部分：

![img](20180223225226.png)

```go
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)      // ["April" "May" "June"]
fmt.Println(summer)  // ["June" "July" "August"]
```

如果切片操作超出 cap(s) 的上限将导致一个 panic 异常，但是超出 len(s) 则意味着扩展了 slice，因为新 slice 的长
度会变大：

```go
fmt.Println(summer[:20])  // panic: out of range

endlessSummer := summer[:5]  // extend a slice (within capacity)
fmt.Println(endlessSummer)   // "[June July August September October]"
fmt.Println(summer)          // "[June July August]"
```

另外，字符串的切片操作和 []byte 字节类型的切片操作是类似的。都写作 x[m:n]，并且都是返回一个原始字节系列的子序列，
底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。

因为 slice 值包含指向第一个 slice 元素的指针，因此向函数传递 slice 将允许在函数内部修改底层数组的元素。换句话说，
复制一个 slice 只是对底层的数组创建了一个新的 slice 别名。

[rev.go](rev.go)

注意，rev.go 文件中的 slice 类型的变量 s 和数组类型的变量 a 的初始化语法的差异。slice 和数组的字面值语法很类似，
但是对于 slice 并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后 slice 的指针指向底层的数组。就像数组
字面值一样，slice 的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者两种风格的混合语法初始化。

和数组不同的是，slice 之间不能比较，因此不能使用`==`操作符来判断两个 slice 是否含有全部相等元素。